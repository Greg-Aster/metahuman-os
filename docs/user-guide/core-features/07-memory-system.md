## Memory System

> **Memory Continuity Roadmap (Phases 1â€‘5)**  
> MetaHuman OS now follows the same layered memory guarantees described in the [Memory Continuity plan](../implementation-plans/memory-continuity-plan.md): every tool/file/action is captured (Phaseâ€¯1), prompts always assemble the right context (Phaseâ€¯2), long conversations are summarized and indexed (Phaseâ€¯3), per-profile/role metadata flows into every call (Phaseâ€¯4), and observability keeps the pipeline honest (Phaseâ€¯5). The sections below explain how that shows up in dayâ€‘toâ€‘day usage.

### Types of Memory

#### Episodic Memory (`memory/episodic/YYYY/*.json`)
Your digital personality's journal. A timeline of:
- **Observations** - Things you capture manually
- **Reflections** - Autonomous thoughts generated by the reflector agent
- **Dreams** - Surreal narratives created during sleep hours
- **Inner Dialogue** - Private thoughts
- **Conversations** - Exchanges with the persona chat

Each memory is stored as JSON:
```json
{
  "id": "evt-20251019143000",
  "timestamp": "2025-10-19T14:30:00.000Z",
  "content": "Met with Sarah about ML project",
  "type": "observation",
  "tags": ["meeting", "work", "ml"],
  "entities": ["Sarah", "ML project"],
  "importance": 0.7,
  "metadata": {
    "cognitiveMode": "dual",
    "processed": true,
    "processedAt": "2025-10-19T14:35:00.000Z",
    "model": "ollama:phi3:mini"
  }
}
```

**Metadata Fields:**
- **cognitiveMode**: The cognitive mode active when the memory was created (dual/agent/emulation)
- **processed**: Whether the organizer agent has enriched this memory
- **processedAt**: Timestamp when enrichment occurred
- **model**: The LLM model used for processing

#### Task Memory (`memory/tasks/`)
Structured to-do items with:
- Status: `todo`, `in_progress`, `blocked`, `done`, `cancelled`
- Priority: `P1` (urgent), `P2` (normal), `P3` (low)
- Dependencies, due dates, tags
- `listId`: The ID of the task list this task belongs to
- `category` or `labels`: For filtering and organization
- `due`, `start`, `end`: ISO timestamps for scheduling
- `reminders`: An array of reminder configurations

```json
{
  "id": "task-20251019143000",
  "title": "Draft proposal",
  "status": "todo",
  "priority": "P2",
  "tags": ["writing", "work"],
  "listId": "list-work-projects",
  "due": "2025-11-10T18:00:00.000Z",
  "created": "2025-10-19T14:30:00.000Z",
  "updated": "2025-10-19T14:30:00.000Z"
}
```

#### Function Memory

Function Memory stores reusable multi-step execution patterns learned from successful operator runs. When the operator encounters a similar task in the future, it can retrieve and execute these proven workflows instead of planning from scratch.

**Architecture:**
```
memory/functions/
â”œâ”€â”€ verified/          # User-approved, trusted functions
â”‚   â””â”€â”€ <uuid>.json    # High-quality, production-ready workflows
â””â”€â”€ drafts/            # Auto-learned, awaiting review
    â””â”€â”€ <uuid>.json    # Automatically discovered patterns
```

**Trust Levels:**
- **Draft**: Automatically learned from operator execution, awaiting user review.
- **Verified**: User-approved, fully trusted for production use.

#### Learning New Functions

The system can automatically learn new functions from successful operator runs. When the operator successfully completes a task that involves at least two different skills and has a success rate of 80% or higher, the system can analyze the sequence of actions and create a new "draft" function. This draft is then stored in the `memory/functions/drafts/` directory for you to review and approve.

The system also includes a deduplication mechanism to avoid creating duplicate functions for similar workflows.

#### Retrieval and Usage

When you give the operator a command, the context builder automatically queries the function memory for relevant guides. If a matching function is found (with a similarity score of 60% or higher), it is injected into the operator's prompt as a "Function Guide". The operator can then use this guide to inform its planning and execution, leading to more efficient and reliable task completion.

The system also includes a fallback mechanism. If the operator encounters repeated errors, it can trigger a "function lookup" to see if there is a known solution to the problem.

#### UI & UX

The function memory is exposed to the user in the web UI in the following ways:

*   **Memory Tab**: A new "Functions" tab in the memory viewer allows you to browse, inspect, edit, and share your functions.
*   **Function Inspector**: A detailed view of each function, showing its step-by-step instructions, examples, and usage statistics.
*   **Operator Console Integration**: When a function is used during an operator run, a chip will be displayed in the operator monitor to indicate which function was used.

### Conversation Continuity & Summaries

- **Session IDs** â€“ Every chat session gets a stable `conversationId` that is stamped onto each memory/event so tool runs, approvals, and summaries stay linked even after restarts.
- **Rolling Buffers + Persistence** â€“ The last ~20 turns live in memory for fast prompting, while the on-disk buffer (`profiles/<user>/state/conversation-buffer-*.json`) keeps history intact across restarts.
- **Vector Index Queue** â€“ New memories go into a per-user queue that batches embedding writes. Capture stays snappy while the background worker feeds the semantic index.
- **Conversation Summaries** â€“ When the buffer overflows, the summarizer agent condenses older turns into `type: "summary"` episodic files. Those summaries automatically appear in prompts and in the Memory tab (watch for the summary badge).

### Memory Browser (Web UI)

The web interface provides a powerful Memory browser with **7 specialized tabs** for organizing and viewing different types of memories. Each tab automatically filters memories based on their type and content.

#### Memory Interaction Controls

Each memory card includes several interactive features:
- **Expand/Collapse Toggle (â–¼/â–¶)**: Click to view full memory content inline
- **Edit Button (âœï¸)**: Click the blue pencil icon to open the memory editor modal
- **Validate Button (+)**: Mark memory as correct for training data quality
- **Delete Button (âˆ’)**: Remove memory immediately

#### Memory Editor Modal

The Memory Editor provides a full-screen editing experience for viewing and modifying memory files:
- **Full-screen modal**: Takes up 80% of screen height with 1200px width
- **Keyboard shortcuts**:
  - Ctrl+S to save changes
  - Esc to close editor
- **Auto-save detection**: Warns when closing with unsaved changes
- **Permission-based**: Requires authentication to edit (read-only in emulation mode for anonymous users)
- **Audit logging**: All edits are logged to audit trail with timestamp and actor
- **JSON formatting**: Automatically pretty-prints JSON content for readability
- **Access**: Via blue pencil icon (âœï¸) next to any memory entry in any tab

#### 1. Conversations Tab ðŸ’¬
- **Purpose**: View user-assistant dialogue exchanges
- **Filtering**: Shows only `type: 'conversation'` memories
- **Content**: Your questions and MetaHuman's responses
- **Filterable by**: Date, cognitive mode, participant
- **Visual**: Standard conversation card layout
- **Actions**: Expand/collapse, edit, validate, delete
- **Inline expansion**: Full conversation content
- **Full-screen editor**: Complete JSON editing

#### 2. Observations Tab ðŸ‘ï¸
- **Purpose**: View manually captured observations and events
- **Filtering**: Shows only `type: 'observation'` memories
- **Content**: Manual captures via `mh capture` command
- **Visual**: Personal notes and event recordings
- **Enrichment**: Tagged and entity-enriched by organizer agent
- **Actions**: Expand/collapse, edit, validate, delete

#### 3. Inner Dialogue Tab ðŸ’­
- **Purpose**: View MetaHuman's internal thoughts and reflections
- **Filtering**: Shows only `type: 'inner_dialogue'` memories
- **Content**:
  - Reflections generated by reflector agent
  - Internal questions from inner curiosity agent
  - Associative memory chains (3-5 linked memories)
- **Visual**: Distinct styling to indicate internal thoughts
- **Important**: These are NEVER shown in main chat (internal thoughts only)
- **Memory access**: Entire lifetime with reflective weighting
- **Actions**: Expand/collapse, edit, validate, delete

#### 4. Dreams Tab ðŸŒ™
- **Purpose**: View surreal dream narratives
- **Filtering**: Shows only `type: 'dream'` memories
- **Content**: Abstract, metaphorical narratives woven from memory fragments
- **Generation**: Created by dreamer agent during sleep cycles
- **Memory access**: Entire lifetime with exponential decay weighting
- **Visual**: Yellow/gold left border to distinguish dream content
- **Metadata**: Shows source memory IDs that inspired the dream
- **Configuration**: Sleep schedule in `etc/sleep.json`
- **Actions**: Expand/collapse, edit, validate, delete

#### 5. Tasks Tab âœ“
- **Purpose**: View all task files from `memory/tasks/`
- **Filtering**: Shows only `type: 'task'` memories
- **Content**: Task titles, status, priority, due dates
- **Organization**: Project hierarchies and categorization
- **Status types**: Active, completed, archived
- **Priority levels**: High, medium, low
- **Visual**: Shows task metadata inline with status badges
- **Actions**: Expand/collapse, edit, complete, delete

#### 6. All Memories Tab ðŸ“š
- **Purpose**: Unified view of all memory types
- **Filtering**: No type restrictions, shows everything
- **Content**: All episodic memories regardless of type
- **Advanced filters**:
  - Date range selection
  - Memory type selector
  - Tag filtering
  - Entity search
  - Cognitive mode filter
- **Bulk operations**: Select multiple memories for export/delete
- **Search**: Full-text search across all fields
- **Visual**: Color-coded by memory type
- **Actions**: All standard memory operations

#### 7. Search Tab ðŸ”
- **Purpose**: Advanced search interface with multiple filters
- **Features**:
  - **Date range picker**: Select specific time periods
  - **Memory type selector**: Filter by conversation, observation, inner_dialogue, dream, task
  - **Tag filtering**: Multi-select tag checkboxes
  - **Entity search**: Find memories mentioning specific people, places, topics
  - **Full-text search**: Search across all memory content
  - **Cognitive mode filter**: Filter by dual, agent, or emulation mode
  - **Semantic search**: Uses vector index if built
- **Results**:
  - Grouped by relevance
  - Sorted by date or similarity score
  - Highlight matching terms
- **Visual**: Clean search interface with filter chips
- **Actions**: All standard memory operations on results

### Memory Validation

Each memory card in the web UI includes validation controls:
- **âœï¸ Button**: Open memory editor modal for full editing
- **+ Button**: Mark memory as correct (useful for training data quality)
- **âˆ’ Button**: Delete memory immediately (fast cleanup)
- **Validation Status**: Shows "correct" or "incorrect" badge if validated

### Capturing Memories

The primary way to give your digital personality a new memory is with the **`capture`** command:

**CLI:**
```bash
./bin/mh capture "Had a productive meeting with the design team today and we decided on the new color palette."
```

**Web UI:**
Navigate to the Chat view and use the input box (memories are auto-captured from conversations).

**Automatic Capture (AI Ingestor):**
```bash
# Place files in the inbox
cp my-notes.txt memory/inbox/

# Run the ingestor agent
./bin/mh agent run ingestor

# View AI-extracted memories in the "AI Ingestor" tab
```

**Audio Capture:**
```bash
# Upload audio via Web UI (Audio view)
# OR place audio files in memory/audio/inbox/

# The transcriber and audio-organizer agents process automatically during sleep
# View transcribed memories in the "Audio" tab
```

### Searching Memory

> **Tip:** The system automatically propagates conversation summaries and recent tool runs into each query via the context builder, so you can reference past sessions even after the rolling buffer resets.

**CLI:**
```bash
./bin/mh remember "design team"
```

This performs:
1. **Semantic search** (if vector index exists) - finds conceptually similar memories (fed by the deferred vector-index queue, so new memories appear after background batching)
2. **Keyword search** (fallback) - simple text matching

**Web UI:**
Use the Memory browser in the left sidebar to browse and search.

### Semantic Search (Vector Embeddings)

MetaHuman OS can build a semantic index of your memories for natural language search.

### Build the Index
```bash
./bin/mh index build
```

This:
1. Reads all episodic memories
2. Generates embeddings using Ollama (`nomic-embed-text` model)
3. Stores vectors in `memory/index/memory-index.json`

### Search Semantically
```bash
./bin/mh index query "when did I meet with Sarah?"
```

Returns memories ranked by semantic similarity (cosine similarity score).

**Note:** The `mh remember` command automatically uses semantic search if an index exists.

---
