## Memory System

> **Memory Continuity Roadmap (Phases 1â€‘5)**  
> MetaHuman OS now follows the same layered memory guarantees described in the [Memory Continuity plan](../implementation-plans/memory-continuity-plan.md): every tool/file/action is captured (Phaseâ€¯1), prompts always assemble the right context (Phaseâ€¯2), long conversations are summarized and indexed (Phaseâ€¯3), per-profile/role metadata flows into every call (Phaseâ€¯4), and observability keeps the pipeline honest (Phaseâ€¯5). The sections below explain how that shows up in dayâ€‘toâ€‘day usage.

### Types of Memory

#### Episodic Memory (`memory/episodic/YYYY/*.json`)
Your digital personality's journal. A timeline of:
- **Observations** - Things you capture manually
- **Reflections** - Autonomous thoughts generated by the reflector agent
- **Dreams** - Surreal narratives created during sleep hours
- **Inner Dialogue** - Private thoughts
- **Conversations** - Exchanges with the persona chat

Each memory is stored as JSON:
```json
{
  "id": "evt-20251019143000",
  "timestamp": "2025-10-19T14:30:00.000Z",
  "content": "Met with Sarah about ML project",
  "type": "observation",
  "tags": ["meeting", "work", "ml"],
  "entities": ["Sarah", "ML project"],
  "importance": 0.7,
  "metadata": {
    "cognitiveMode": "dual",
    "processed": true,
    "processedAt": "2025-10-19T14:35:00.000Z",
    "model": "ollama:phi3:mini"
  }
}
```

**Metadata Fields:**
- **cognitiveMode**: The cognitive mode active when the memory was created (dual/agent/emulation)
- **processed**: Whether the organizer agent has enriched this memory
- **processedAt**: Timestamp when enrichment occurred
- **model**: The LLM model used for processing

#### Task Memory (`memory/tasks/`)
Structured to-do items with:
- Status: `todo`, `in_progress`, `blocked`, `done`, `cancelled`
- Priority: `P1` (urgent), `P2` (normal), `P3` (low)
- Dependencies, due dates, tags
- `listId`: The ID of the task list this task belongs to
- `category` or `labels`: For filtering and organization
- `due`, `start`, `end`: ISO timestamps for scheduling
- `reminders`: An array of reminder configurations

```json
{
  "id": "task-20251019143000",
  "title": "Draft proposal",
  "status": "todo",
  "priority": "P2",
  "tags": ["writing", "work"],
  "listId": "list-work-projects",
  "due": "2025-11-10T18:00:00.000Z",
  "created": "2025-10-19T14:30:00.000Z",
  "updated": "2025-10-19T14:30:00.000Z"
}
```

#### Function Memory

Function Memory stores reusable multi-step execution patterns learned from successful operator runs. When the operator encounters a similar task in the future, it can retrieve and execute these proven workflows instead of planning from scratch.

**Architecture:**
```
memory/functions/
â”œâ”€â”€ verified/          # User-approved, trusted functions
â”‚   â””â”€â”€ <uuid>.json    # High-quality, production-ready workflows
â””â”€â”€ drafts/            # Auto-learned, awaiting review
    â””â”€â”€ <uuid>.json    # Automatically discovered patterns
```

**Trust Levels:**
- **Draft**: Automatically learned from operator execution, awaiting user review.
- **Verified**: User-approved, fully trusted for production use.

#### Learning New Functions

The system can automatically learn new functions from successful operator runs. When the operator successfully completes a task that involves at least two different skills and has a success rate of 80% or higher, the system can analyze the sequence of actions and create a new "draft" function. This draft is then stored in the `memory/functions/drafts/` directory for you to review and approve.

The system also includes a deduplication mechanism to avoid creating duplicate functions for similar workflows.

#### Retrieval and Usage

When you give the operator a command, the context builder automatically queries the function memory for relevant guides. If a matching function is found (with a similarity score of 60% or higher), it is injected into the operator's prompt as a "Function Guide". The operator can then use this guide to inform its planning and execution, leading to more efficient and reliable task completion.

The system also includes a fallback mechanism. If the operator encounters repeated errors, it can trigger a "function lookup" to see if there is a known solution to the problem.

#### UI & UX

The function memory is exposed to the user in the web UI in the following ways:

*   **Memory Tab**: A new "Functions" tab in the memory viewer allows you to browse, inspect, edit, and share your functions.
*   **Function Inspector**: A detailed view of each function, showing its step-by-step instructions, examples, and usage statistics.
*   **Operator Console Integration**: When a function is used during an operator run, a chip will be displayed in the operator monitor to indicate which function was used.

### Conversation Continuity & Summaries

- **Session IDs** â€“ Every chat session gets a stable `conversationId` that is stamped onto each memory/event so tool runs, approvals, and summaries stay linked even after restarts.
- **Rolling Buffers + Persistence** â€“ The last ~20 turns live in memory for fast prompting, while the on-disk buffer (`profiles/<user>/state/conversation-buffer-*.json`) keeps history intact across restarts.
- **Vector Index Queue** â€“ New memories go into a per-user queue that batches embedding writes. Capture stays snappy while the background worker feeds the semantic index.
- **Conversation Summaries** â€“ When the buffer overflows, the summarizer agent condenses older turns into `type: "summary"` episodic files. Those summaries automatically appear in prompts and in the Memory tab (watch for the summary badge).

### Memory Browser (Web UI)

The web interface provides a powerful Memory browser with **7 specialized tabs** for organizing and viewing different types of memories. Each tab automatically filters memories based on their tags, links, and types.

#### Memory Interaction Controls

Each memory card includes several interactive features:
- **Expand/Collapse Toggle (â–¼/â–¶)**: Click to view full memory content inline
- **Edit Button (âœï¸)**: Click the blue pencil icon to open the memory editor modal
- **Validate Button (+)**: Mark memory as correct for training data quality
- **Delete Button (âˆ’)**: Remove memory immediately

#### Memory Editor Modal

The Memory Editor provides a full-screen editing experience for viewing and modifying memory files:
- **Full-screen modal**: Takes up 80% of screen height with 1200px width
- **Keyboard shortcuts**:
  - Ctrl+S to save changes
  - Esc to close editor
- **Auto-save detection**: Warns when closing with unsaved changes
- **Permission-based**: Requires authentication to edit (read-only in emulation mode)
- **Audit logging**: All edits are logged to audit trail with timestamp and actor
- **JSON formatting**: Automatically pretty-prints JSON content for readability

To use the editor: Click the blue pencil icon (âœï¸) next to any memory entry in any tab.

#### Episodic Tab
- **Purpose**: View all captured observations and manually created events
- **Filtering**: Shows all memories without type-specific filters
- **Visual**: Standard white/dark background cards
- **Actions**: Expand/collapse, edit, validate (mark correct), delete

#### Reflections Tab
- **Purpose**: View AI-generated reflections from the reflector agent
- **Filtering**: Memories with `type: "reflection"`
- **Content**: 1-3 sentence first-person thoughts connecting multiple memories
- **Visual**: Standard cards with reflection-specific metadata
- **Actions**: Expand/collapse, edit, validate, delete

#### Tasks Tab
- **Purpose**: View all task files from `memory/tasks/`
- **Filtering**: Task JSON files (active, completed, projects)
- **Content**: Task titles, status, priority, due dates
- **Visual**: Shows task metadata inline

#### Curated Tab
- **Purpose**: View hand-picked, high-quality memories from `memory/curated/`
- **Filtering**: Markdown files in the curated directory
- **Use Case**: Store important reference documents, key learnings, golden memories
- **Visual**: Shows file names and full content when expanded

#### AI Ingestor Tab ðŸ¤–
- **Purpose**: View memories automatically created by the ingestor agent
- **Filtering**: Memories with:
  - Tags: `ingested` or `ai`
  - Links: `type: "source"` (pointing to original file)
- **Visual**: **Purple left border** to distinguish from manual captures
- **Content**: Extracted insights from files placed in `memory/inbox/`
- **Metadata**: Shows tags, entities, and source file links

#### Audio Tab ðŸŽµ
- **Purpose**: View memories from transcribed audio recordings
- **Filtering**: Memories with tags: `audio` or `transcript`
- **Visual**: **Blue left border** to distinguish audio-sourced content
- **Content**: Key points extracted from audio transcripts
- **Workflow**: Audio files â†’ Transcriber â†’ Audio Organizer â†’ Episodic memories
- **Metadata**: Shows tags, entities, and links to original transcript files

#### Dreams Tab ðŸ’­
- **Purpose**: View surreal dream narratives generated by the dreamer agent
- **Filtering**: Memories with `type: "dream"`
- **Visual**: **Yellow left border** to distinguish dream content
- **Content**: Abstract, metaphorical narratives woven from memory fragments
- **Metadata**: Shows source memory IDs that inspired the dream
- **Generated**: During nightly sleep cycles (configurable in `etc/sleep.json`)
- **Actions**: Expand/collapse, edit, validate, delete

### Memory Validation

Each memory card in the web UI includes validation controls:
- **âœï¸ Button**: Open memory editor modal for full editing
- **+ Button**: Mark memory as correct (useful for training data quality)
- **âˆ’ Button**: Delete memory immediately (fast cleanup)
- **Validation Status**: Shows "correct" or "incorrect" badge if validated

### Capturing Memories

The primary way to give your digital personality a new memory is with the **`capture`** command:

**CLI:**
```bash
./bin/mh capture "Had a productive meeting with the design team today and we decided on the new color palette."
```

**Web UI:**
Navigate to the Chat view and use the input box (memories are auto-captured from conversations).

**Automatic Capture (AI Ingestor):**
```bash
# Place files in the inbox
cp my-notes.txt memory/inbox/

# Run the ingestor agent
./bin/mh agent run ingestor

# View AI-extracted memories in the "AI Ingestor" tab
```

**Audio Capture:**
```bash
# Upload audio via Web UI (Audio view)
# OR place audio files in memory/audio/inbox/

# The transcriber and audio-organizer agents process automatically during sleep
# View transcribed memories in the "Audio" tab
```

### Searching Memory

> **Tip:** The system automatically propagates conversation summaries and recent tool runs into each query via the context builder, so you can reference past sessions even after the rolling buffer resets.

**CLI:**
```bash
./bin/mh remember "design team"
```

This performs:
1. **Semantic search** (if vector index exists) - finds conceptually similar memories (fed by the deferred vector-index queue, so new memories appear after background batching)
2. **Keyword search** (fallback) - simple text matching

**Web UI:**
Use the Memory browser in the left sidebar to browse and search.

### Semantic Search (Vector Embeddings)

MetaHuman OS can build a semantic index of your memories for natural language search.

### Build the Index
```bash
./bin/mh index build
```

This:
1. Reads all episodic memories
2. Generates embeddings using Ollama (`nomic-embed-text` model)
3. Stores vectors in `memory/index/memory-index.json`

### Search Semantically
```bash
./bin/mh index query "when did I meet with Sarah?"
```

Returns memories ranked by semantic similarity (cosine similarity score).

**Note:** The `mh remember` command automatically uses semantic search if an index exists.

---
