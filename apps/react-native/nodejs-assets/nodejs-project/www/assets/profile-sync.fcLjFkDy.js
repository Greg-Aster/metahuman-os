import{E as D,F as C,l as u,G as M,_ as Y,D as R}from"./api-config.BAZ_dc_Y.js";import{h as T}from"./server-health.C6FYljDX.js";import{getSyncServerCredentials as A,updateSyncTimestamp as q,saveSyncServerCredentials as B,getRecentMemories as _,getSetting as I,getUnsyncedMemories as L,getAllPersona as x,savePersona as P,importMemories as E,saveTask as z,setSetting as g,importPersona as J,markMemoriesSynced as V,getActiveTasks as W}from"./local-memory.qidMz0ak.js";const j="activeProfile",$="profiles";async function O(){return I($,[])}async function G(){const e=await I(j,null);return e&&(await O()).find(t=>t.id===e)||null}async function b(e){await g(j,e)}async function se(e,a){const t=new Date().toISOString(),o=crypto.randomUUID(),s={id:o,name:e,createdAt:t,updatedAt:t,source:"local",version:1,memoryCount:0,personaKeys:a?Object.keys(a):["core"]},n={core:{name:e,traits:[],voice:"neutral",values:[],summary:`${e}'s digital personality`}};for(const[i,c]of Object.entries(n))await P(i,c);const r=await O();return r.push(s),await g($,r),await b(o),s}async function re(e){if(!R(T).connected)throw new Error("Server not connected. Cannot download profile.");const t=(d,f,v,h)=>{e?.({phase:d,current:f,total:v,message:h})};t("metadata",0,1,"Fetching profile info...");const o=await u("/api/profile-sync/metadata");if(!o.ok)throw new Error("Failed to fetch profile metadata");const s=await o.json();t("metadata",1,1,"Profile info received"),t("persona",0,s.personaKeys?.length||4,"Downloading persona...");const n=s.personaKeys||["core","relationships","routines","decision-rules"];let r=0;for(const d of n){try{const f=await u(`/api/persona-${d}`);if(f.ok){const v=await f.json();await P(d,v)}}catch(f){console.warn(`Failed to download persona ${d}:`,f)}r++,t("persona",r,n.length,`Downloaded ${d}`)}t("memories",0,s.memoryCount||100,"Downloading memories...");const i=100;let c=0,m=0;const S=s.memoryCount||0;for(;c<S;){try{const d=await u(`/api/profile-sync/memories?offset=${c}&limit=${i}`);if(d.ok){const f=await d.json();if(f.memories&&f.memories.length>0&&(await E(f.memories),m+=f.memories.length,t("memories",m,S,`Downloaded ${m} memories`)),!f.hasMore)break}else break}catch(d){console.warn("Failed to download memories batch:",d);break}c+=i}t("tasks",0,1,"Downloading tasks...");try{const d=await u("/api/profile-sync/tasks");if(d.ok){const f=await d.json();if(f.tasks)for(const v of f.tasks)await z(v)}}catch(d){console.warn("Failed to download tasks:",d)}t("tasks",1,1,"Tasks downloaded");const l=new Date().toISOString(),p={id:s.profileId||crypto.randomUUID(),name:s.name||"Downloaded Profile",createdAt:s.createdAt||l,updatedAt:l,source:"server",serverUrl:M(),version:s.version||1,memoryCount:m,personaKeys:n},y=await O(),w=y.findIndex(d=>d.serverUrl===M());return w>=0?y[w]=p:y.push(p),await g($,y),await b(p.id),await g("lastProfileSync",l),t("complete",1,1,"Profile download complete"),p}async function H(){if(!R(T).connected)throw new Error("Server not connected. Cannot upload changes.");const a=[];let t=0;const o=await L();if(o.length>0)try{const r=await u("/api/profile-sync/memories",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({memories:o})});if(r.ok){const i=await r.json(),c=o.map(m=>m.id);await V(c,new Date().toISOString()),t+=c.length}else a.push(`Failed to upload memories: ${r.status}`)}catch(r){a.push(`Memory upload error: ${r instanceof Error?r.message:"Unknown"}`)}const s=await x();for(const r of s)if(!r.syncedAt||r.localModifiedAt&&r.localModifiedAt>r.syncedAt)try{(await u(`/api/persona-${r.key}`,{method:"PUT",headers:{"Content-Type":"application/json"},body:JSON.stringify(r.data)})).ok?(await J(r.key,r.data,new Date().toISOString()),t++):a.push(`Failed to upload persona ${r.key}`)}catch(i){a.push(`Persona upload error (${r.key}): ${i instanceof Error?i.message:"Unknown"}`)}await g("lastProfileSync",new Date().toISOString());const n=await G();if(n){n.updatedAt=new Date().toISOString();const r=await O(),i=r.findIndex(c=>c.id===n.id);i>=0&&(r[i]=n,await g($,r))}return{uploaded:t,errors:a}}async function oe(){if(!R(T).connected)return{uploaded:0,downloaded:0,errors:["Server not connected"]};const a=[];let t=0,o=0;const s=await H();t=s.uploaded,a.push(...s.errors);const n=await I("lastProfileSync",null);try{const r=await u(`/api/profile-sync/changes?since=${n||""}`);if(r.ok){const i=await r.json();if(i.memories&&i.memories.length>0&&(await E(i.memories),o+=i.memories.length),i.persona)for(const[c,m]of Object.entries(i.persona))await J(c,m,new Date().toISOString()),o++}}catch(r){a.push(`Sync pull error: ${r instanceof Error?r.message:"Unknown"}`)}return await g("lastProfileSync",new Date().toISOString()),{uploaded:t,downloaded:o,errors:a}}async function ne(){const e=await I("lastProfileSync",null),a=await L(),o=(await x()).filter(s=>!s.syncedAt||s.localModifiedAt&&s.localModifiedAt>s.syncedAt).length;return{lastSync:e,pendingUpload:a.length+o,pendingDownload:0,conflicts:0,syncing:!1}}async function ae(){const e=await G();if(!e)throw new Error("No active profile");const a=await x(),t={};for(const n of a)t[n.key]=n.data;const o=await _(1e4),s=await W();return{metadata:e,persona:t,memories:o,tasks:s,settings:{}}}async function ie(e){const a=new Date().toISOString();for(const[n,r]of Object.entries(e.persona))await P(n,r);if(e.memories&&e.memories.length>0&&await E(e.memories),e.tasks)for(const n of e.tasks)await z(n);const t={...e.metadata,source:"imported",updatedAt:a},o=await O(),s=o.findIndex(n=>n.id===t.id);return s>=0?o[s]=t:o.push(t),await g($,o),await b(t.id),t}async function ce(e){const t=(await O()).filter(s=>s.id!==e);await g($,t),await I(j,null)===e&&await g(j,null)}async function K(e){const a=await u("/api/profile-sync/credentials",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({credentials:e})});if(!a.ok)throw console.error("[profile-sync] Failed to save credentials to filesystem:",a.status),new Error("Failed to save credentials");console.log("[profile-sync] Credentials saved to filesystem via unified API")}async function le(){try{const e=await u("/api/profile-sync/credentials");return e.ok&&(await e.json()).credentials||null}catch(e){return console.warn("[profile-sync] Error reading credentials from filesystem:",e),null}}async function de(e){const a=M();if(!a)return console.log("[profile-sync] No sync server configured"),null;try{const t={"Content-Type":"application/json"},o=D(a),s=await C(`${o}/api/profile-sync/credentials`,{method:"GET",headers:t,credentials:"include"});if(!s.ok){const r=await s.text();return console.warn("[profile-sync] Failed to fetch credentials:",s.status,r),null}const n=await s.json();return n.success&&n.credentials?(await K(n.credentials),console.log("[profile-sync] Credentials synced from server to filesystem"),n.credentials):null}catch(t){return console.warn("[profile-sync] Error fetching credentials:",t),null}}async function N(e,a,t){try{const s=`${D(e)}/api/auth/login`;console.log("[profile-sync] Authenticating with",s);const n=await C(s,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:a,password:t}),credentials:"include"});if(!n.ok){const c=await n.text();return{success:!1,error:`Authentication failed: ${n.status} - ${c}`}}const r=await n.json();if(!r.success)return{success:!1,error:r.error||"Authentication failed"};let i=r.sessionId||r.session;if(!i){const c=n.headers.get("set-cookie");c&&(i=c.match(/mh_session=([^;]+)/)?.[1])}return i?{success:!0,cookie:`mh_session=${i}`}:(console.error("[profile-sync] No session ID in auth response:",{data:r,headers:Object.fromEntries(n.headers.entries())}),{success:!1,error:"No session ID returned from server"})}catch(o){return{success:!1,error:o.message}}}async function Q(e,a){try{const o=`${D(e)}/api/profile-sync/credentials`;console.log("[profile-sync] Fetching credentials from",o);const s=await C(o,{method:"GET",headers:{Cookie:a},credentials:"include"});if(!s.ok){if(s.status===403)return console.log("[profile-sync] Credentials sync requires owner role - skipping"),{success:!0,credentials:void 0};const r=await s.text();return{success:!1,error:`Failed to fetch credentials: ${s.status} - ${r}`}}const n=await s.json();return n.error?{success:!1,error:n.error}:{success:!0,credentials:n.credentials}}catch(t){return{success:!1,error:t.message}}}async function X(e,a,t){const o=await N(e,a,t);return{success:o.success,error:o.error}}async function fe(e,a,t){const o=await X(e,a,t);return o.success?(await B({serverUrl:e.replace(/\/$/,""),username:a,password:t,verified:!0}),{success:!0}):o}async function me(e,a){const t={includeMemories:!0,includeCredentials:!0,priorityOnly:!0,memoryDays:7,...a},o=await A();if(!o)return{success:!1,error:"No sync server configured. Please set up sync server first."};const s={success:!1};try{e?.({phase:"authenticating",message:"Connecting to server..."});const n=await N(o.serverUrl,o.username,o.password);if(!n.success||!n.cookie)return e?.({phase:"error",message:"Authentication failed",error:n.error}),{success:!1,error:n.error};const r=n.cookie;e?.({phase:"fetching-profile",message:"Downloading profile..."});const i=D(o.serverUrl),c=t.priorityOnly?"/api/profile-sync/export-priority":"/api/profile-sync/export",m=t.priorityOnly?await C(`${i}${c}`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:o.username,password:o.password})}):await C(`${i}${c}`,{method:"GET",headers:{Cookie:r},credentials:"include"});if(!m.ok){const l=await m.text();return e?.({phase:"error",message:"Failed to fetch profile",error:l}),{success:!1,error:`Failed to fetch profile: ${m.status}`}}const S=await m.json();s.profileFiles=S.files?.length||0,e?.({phase:"importing",message:"Setting up local user...",current:0,total:s.profileFiles});try{const l=await u("/api/auth/sync-user",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({username:o.username,password:o.password,displayName:o.username,role:"owner"})});if(l.ok){const w=await l.json();console.log("[profile-sync] Local user created/authenticated:",w)}else{const w=await l.text();console.error("[profile-sync] Failed to create local user:",l.status,w),console.log("[profile-sync] Continuing despite sync-user error...")}e?.({phase:"importing",message:"Importing profile files...",current:0,total:s.profileFiles});const p=await u("/api/profile-sync/import",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(S)});if(!p.ok){const w=await p.text();return console.error("[profile-sync] Import failed:",p.status,w),e?.({phase:"error",message:"Failed to import profile",error:w}),{success:!1,error:`Import failed: ${p.status}`}}const y=await p.json();console.log("[profile-sync] Import result:",y),e?.({phase:"importing",message:`Imported ${y.imported||s.profileFiles} files`,current:s.profileFiles,total:s.profileFiles})}catch(l){return console.error("[profile-sync] Import error:",l),e?.({phase:"error",message:"Import failed",error:l.message}),{success:!1,error:l.message}}if(t.includeCredentials){e?.({phase:"fetching-credentials",message:"Syncing credentials..."});const l=await Q(o.serverUrl,r);l.success&&l.credentials&&(await K(l.credentials),s.credentialsSynced=!0,console.log("[profile-sync] Credentials synced to filesystem:",Object.keys(l.credentials)))}if(t.includeMemories){const l=t.memoryDays>0?`&days=${t.memoryDays}`:"",p=t.memoryDays>0?` (last ${t.memoryDays} days)`:"";e?.({phase:"importing",message:"Checking local memories..."});let y=[];try{const h=await u("/api/memories?idsOnly=true");h.ok&&(y=(await h.json()).ids||[],console.log(`[profile-sync] Found ${y.length} local memories to exclude`))}catch(h){console.warn("[profile-sync] Could not get local memory IDs:",h)}const w=y.length>0?`&exclude=${y.slice(0,500).join(",")}`:"";e?.({phase:"importing",message:`Syncing memories${p}...`});let d=0,f=0,v=!0;for(;v;){const h=await C(`${i}/api/profile-sync/memories?offset=${d}&limit=100${l}${w}`,{method:"GET",headers:{Cookie:r},credentials:"include"});if(!h.ok){console.warn("[profile-sync] Memory fetch failed:",h.status);break}const k=await h.json();if(k.memories&&k.memories.length>0){for(const F of k.memories)try{const U=await u("/api/memory/sync/push",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({memory:F})});U.ok||U.status!==409&&console.warn(`[profile-sync] Memory push failed for ${F.id}:`,U.status)}catch(U){console.warn(`[profile-sync] Memory push error for ${F.id}:`,U)}f+=k.memories.length,e?.({phase:"importing",message:`Imported ${f} memories...`,current:f,total:k.total})}v=k.hasMore||!1,d+=100}s.memoriesImported=f}return await q(),e?.({phase:"complete",message:"Sync complete!"}),s.success=!0,s}catch(n){const r=n.message;return e?.({phase:"error",message:"Sync failed",error:r}),{success:!1,error:r}}}async function ue(){const e=await A();return e?{configured:!0,serverUrl:e.serverUrl,username:e.username,lastSyncAt:e.lastSyncAt,verified:e.verified}:{configured:!1}}async function pe(){const{clearSyncServerCredentials:e}=await Y(async()=>{const{clearSyncServerCredentials:a}=await import("./local-memory.qidMz0ak.js");return{clearSyncServerCredentials:a}},[]);await e()}async function ye(){const e=await A();if(!e)throw new Error("No sync server configured");const t=(await _(1e5)).length,o=e.lastSyncAt||null,s=await N(e.serverUrl,e.username,e.password);if(!s.success||!s.cookie)return{connected:!1,serverUrl:e.serverUrl,serverUsername:e.username,error:s.error||"Authentication failed",server:{memoryCount:0},local:{memoryCount:t,lastSync:o||void 0},differences:{newMemoriesOnServer:0,newerOnServer:!1,syncRecommended:!1}};try{const n=D(e.serverUrl),r=await C(`${n}/api/status`,{method:"GET",headers:{Cookie:s.cookie},credentials:"include"});if(!r.ok)throw new Error(`Server status check failed: ${r.status}`);const i=await r.json(),c=i.memoryStats?.totalFiles||0,m=i.lastUpdated||null,S=Math.max(0,c-t),l=m&&o?new Date(m)>new Date(o):c>t;return{connected:!0,serverUrl:e.serverUrl,serverUsername:e.username,server:{memoryCount:c,lastUpdated:m},local:{memoryCount:t,lastSync:o||void 0},differences:{newMemoriesOnServer:S,newerOnServer:l,syncRecommended:S>0||l}}}catch(n){return{connected:!0,serverUrl:e.serverUrl,serverUsername:e.username,error:n.message,server:{memoryCount:0},local:{memoryCount:t,lastSync:o||void 0},differences:{newMemoriesOnServer:0,newerOnServer:!1,syncRecommended:!1}}}}export{ue as a,pe as b,fe as c,ye as d,me as e,de as f,le as g,O as h,G as i,ne as j,re as k,oe as l,se as m,ae as n,ie as o,ce as p,K as s,X as t,H as u};
