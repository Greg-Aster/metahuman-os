const g=(e,t)=>t.some(n=>e instanceof n);let D,M;function O(){return D||(D=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function k(){return M||(M=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const S=new WeakMap,m=new WeakMap,l=new WeakMap;function j(e){const t=new Promise((n,s)=>{const r=()=>{e.removeEventListener("success",o),e.removeEventListener("error",a)},o=()=>{n(u(e.result)),r()},a=()=>{s(e.error),r()};e.addEventListener("success",o),e.addEventListener("error",a)});return l.set(t,e),t}function L(e){if(S.has(e))return;const t=new Promise((n,s)=>{const r=()=>{e.removeEventListener("complete",o),e.removeEventListener("error",a),e.removeEventListener("abort",a)},o=()=>{n(),r()},a=()=>{s(e.error||new DOMException("AbortError","AbortError")),r()};e.addEventListener("complete",o),e.addEventListener("error",a),e.addEventListener("abort",a)});S.set(e,t)}let b={get(e,t,n){if(e instanceof IDBTransaction){if(t==="done")return S.get(e);if(t==="store")return n.objectStoreNames[1]?void 0:n.objectStore(n.objectStoreNames[0])}return u(e[t])},set(e,t,n){return e[t]=n,!0},has(e,t){return e instanceof IDBTransaction&&(t==="done"||t==="store")?!0:t in e}};function P(e){b=e(b)}function C(e){return k().includes(e)?function(...t){return e.apply(I(this),t),u(this.request)}:function(...t){return u(e.apply(I(this),t))}}function T(e){return typeof e=="function"?C(e):(e instanceof IDBTransaction&&L(e),g(e,O())?new Proxy(e,b):e)}function u(e){if(e instanceof IDBRequest)return j(e);if(m.has(e))return m.get(e);const t=T(e);return t!==e&&(m.set(e,t),l.set(t,e)),t}const I=e=>l.get(e);function N(e,t,{blocked:n,upgrade:s,blocking:r,terminated:o}={}){const a=indexedDB.open(e,t),f=u(a);return s&&a.addEventListener("upgradeneeded",c=>{s(u(a.result),c.oldVersion,c.newVersion,u(a.transaction),c)}),n&&a.addEventListener("blocked",c=>n(c.oldVersion,c.newVersion,c)),f.then(c=>{o&&c.addEventListener("close",()=>o()),r&&c.addEventListener("versionchange",d=>r(d.oldVersion,d.newVersion,d))}).catch(()=>{}),f}const V=["get","getKey","getAll","getAllKeys","count"],F=["put","add","delete","clear"],w=new Map;function B(e,t){if(!(e instanceof IDBDatabase&&!(t in e)&&typeof t=="string"))return;if(w.get(t))return w.get(t);const n=t.replace(/FromIndex$/,""),s=t!==n,r=F.includes(n);if(!(n in(s?IDBIndex:IDBObjectStore).prototype)||!(r||V.includes(n)))return;const o=async function(a,...f){const c=this.transaction(a,r?"readwrite":"readonly");let d=c.store;return s&&(d=d.index(f.shift())),(await Promise.all([d[n](...f),r&&c.done]))[0]};return w.set(t,o),o}P(e=>({...e,get:(t,n,s)=>B(t,n)||e.get(t,n,s),has:(t,n)=>!!B(t,n)||e.has(t,n)}));const R=["continue","continuePrimaryKey","advance"],A={},p=new WeakMap,x=new WeakMap,W={get(e,t){if(!R.includes(t))return e[t];let n=A[t];return n||(n=A[t]=function(...s){p.set(this,x.get(this)[t](...s))}),n}};async function*_(...e){let t=this;if(t instanceof IDBCursor||(t=await t.openCursor(...e)),!t)return;t=t;const n=new Proxy(t,W);for(x.set(n,t),l.set(n,I(t));t;)yield n,t=await(p.get(n)||t.continue()),p.delete(n)}function v(e,t){return t===Symbol.asyncIterator&&g(e,[IDBIndex,IDBObjectStore,IDBCursor])||t==="iterate"&&g(e,[IDBIndex,IDBObjectStore])}P(e=>({...e,get(t,n,s){return v(t,n)?_:e.get(t,n,s)},has(t,n){return v(t,n)||e.has(t,n)}}));const K="metahuman-local",U=3,E=50;let y=null;async function i(){return y||(y=await N(K,U,{upgrade(e){if(!e.objectStoreNames.contains("memories")){const t=e.createObjectStore("memories",{keyPath:"id"});t.createIndex("by-timestamp","timestamp"),t.createIndex("by-type","type"),t.createIndex("by-synced","synced"),t.createIndex("by-deleted","deleted")}if(e.objectStoreNames.contains("persona")||e.createObjectStore("persona",{keyPath:"key"}),!e.objectStoreNames.contains("tasks")){const t=e.createObjectStore("tasks",{keyPath:"id"});t.createIndex("by-status","status"),t.createIndex("by-synced","synced")}e.objectStoreNames.contains("settings")||e.createObjectStore("settings",{keyPath:"key"}),e.objectStoreNames.contains("syncMeta")||e.createObjectStore("syncMeta",{keyPath:"key"}),e.objectStoreNames.contains("users")||e.createObjectStore("users",{keyPath:"username"}).createIndex("by-profileType","profileType"),e.objectStoreNames.contains("conversationBuffers")||e.createObjectStore("conversationBuffers",{keyPath:"mode"})}}),y)}async function J(e){const t=await i(),n=new Date().toISOString(),s={...e,synced:!1,localModifiedAt:n};return await t.put("memories",s),s}async function Q(e=50){return(await(await i()).getAllFromIndex("memories","by-timestamp")).filter(s=>!s.deleted).slice(-e).reverse()}async function X(){return(await i()).getAllFromIndex("memories","by-synced",!1)}async function Z(e,t){const s=(await i()).transaction("memories","readwrite");for(const r of e){const o=await s.store.get(r);o&&(o.synced=!0,o.syncedAt=t,o.serverModifiedAt=t,await s.store.put(o))}await s.done}async function q(e){const n=(await i()).transaction("memories","readwrite");for(const s of e){const r=await n.store.get(s.id);r?r.synced&&s.serverModifiedAt&&(!r.serverModifiedAt||s.serverModifiedAt>r.serverModifiedAt)&&await n.store.put({...s,synced:!0,syncedAt:new Date().toISOString()}):await n.store.put({...s,synced:!0,syncedAt:new Date().toISOString()})}await n.done}async function ee(){return(await i()).getAll("persona")}async function te(e,t){const n=await i(),s=new Date().toISOString(),r={key:e,data:t,localModifiedAt:s};return await n.put("persona",r),r}async function ne(e,t,n){const s=await i(),r=await s.get("persona",e);(!r||r.syncedAt)&&await s.put("persona",{key:e,data:t,syncedAt:n,localModifiedAt:n})}async function se(e){const t=await i(),n={...e,synced:!1};return await t.put("tasks",n),n}async function re(){return(await(await i()).getAll("tasks")).filter(n=>!n.deleted&&(n.status==="pending"||n.status==="active"))}async function Y(e,t){return(await(await i()).get("settings",e))?.value??t}async function G(e,t){await(await i()).put("settings",{key:e,value:t,updatedAt:new Date().toISOString()})}async function $(e){const n=await(await i()).get("conversationBuffers",e);return n||{mode:e,messages:[],lastUpdated:new Date().toISOString(),messageLimit:E}}async function oe(e,t){const n=await i();let s=await n.get("conversationBuffers",e);s||(s={mode:e,messages:[],lastUpdated:new Date().toISOString(),messageLimit:E});const r={...t,timestamp:t.timestamp||Date.now()};if(s.messages.push(r),s.messages.length>s.messageLimit){const o=s.messages.length-s.messageLimit;s.messages=s.messages.slice(o)}return s.lastUpdated=new Date().toISOString(),await n.put("conversationBuffers",s),s}async function ae(e){return(await $(e)).messages.filter(n=>n.role!=="system"&&!n.meta?.summaryMarker)}const h="syncServerCredentials";async function z(e){const t={...e,password:btoa(e.password)};await G(h,t)}async function H(){const e=await Y(h,null);if(!e)return null;try{return{...e,password:atob(e.password)}}catch{return e}}async function ie(){await(await i()).delete("settings",h)}async function ce(){const e=await H();e&&await z({...e,lastSyncAt:new Date().toISOString()})}export{oe as appendToBuffer,ie as clearSyncServerCredentials,re as getActiveTasks,ee as getAllPersona,$ as getConversationBuffer,i as getDB,ae as getDisplayMessages,Q as getRecentMemories,Y as getSetting,H as getSyncServerCredentials,X as getUnsyncedMemories,q as importMemories,ne as importPersona,Z as markMemoriesSynced,J as saveMemory,te as savePersona,z as saveSyncServerCredentials,se as saveTask,G as setSetting,ce as updateSyncTimestamp};
